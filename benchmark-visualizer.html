<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLM Training Game - Benchmark Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0e27;
      color: #e0e0e0;
      padding: 20px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 10px;
    }
    
    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }
    
    .status {
      font-size: 1.2em;
      opacity: 0.9;
    }
    
    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .card {
      background: #1a1f3a;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }
    
    .card.highlight {
      border: 2px solid #4ade80;
      background: linear-gradient(135deg, #1a1f3a 0%, #1f2845 100%);
    }
    
    .card h2 {
      font-size: 0.9em;
      text-transform: uppercase;
      color: #a0a0a0;
      margin-bottom: 10px;
    }
    
    .metric {
      font-size: 2.5em;
      font-weight: bold;
      color: #4ade80;
    }
    
    .sub-metric {
      font-size: 0.9em;
      color: #a0a0a0;
      margin-top: 5px;
    }
    
    .progress-bar {
      width: 100%;
      height: 30px;
      background: #0a0e27;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    
    .activity-log {
      background: #1a1f3a;
      padding: 20px;
      border-radius: 10px;
      max-height: 400px;
      overflow-y: auto;
    }
    
    .activity-log h2 {
      font-size: 1.2em;
      margin-bottom: 15px;
      color: #4ade80;
    }
    
    .log-entry {
      padding: 8px 12px;
      margin-bottom: 5px;
      background: #0a0e27;
      border-radius: 5px;
      font-size: 0.9em;
      display: flex;
      justify-content: space-between;
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .log-entry .time {
      color: #667eea;
      font-family: monospace;
    }
    
    .log-entry.success {
      border-left: 3px solid #4ade80;
    }
    
    .log-entry.warning {
      border-left: 3px solid #fbbf24;
    }
    
    .log-entry.error {
      border-left: 3px solid #ef4444;
    }
    
    .phase-indicator {
      display: flex;
      justify-content: space-between;
      margin: 20px 0;
      padding: 20px;
      background: #1a1f3a;
      border-radius: 10px;
    }
    
    .phase {
      flex: 1;
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      margin: 0 5px;
      transition: all 0.3s ease;
      font-size: 1.1em;
      font-weight: 600;
      border: 2px solid transparent;
    }
    
    .phase.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transform: scale(1.1);
      border-color: #4ade80;
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
      animation: pulseGlow 2s infinite;
    }
    
    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
      }
      50% {
        box-shadow: 0 0 30px rgba(102, 126, 234, 0.9);
      }
    }
    
    .phase.completed {
      background: #4ade80;
      color: #0a0e27;
    }
    
    .phase.pending {
      background: #2a2f4a;
      opacity: 0.5;
    }
    
    .chart-container {
      background: #1a1f3a;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
    }
    
    canvas {
      max-width: 100%;
    }
    
    .student-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 10px;
      background: #1a1f3a;
      padding: 20px;
      border-radius: 10px;
    }
    
    .student-card {
      aspect-ratio: 1;
      background: #0a0e27;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8em;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .student-card.active {
      background: #4ade80;
      color: #0a0e27;
      font-weight: bold;
    }
    
    .student-card.asking {
      background: #667eea;
      animation: pulse 2s infinite;
    }
    
    .student-card.answering {
      background: #fbbf24;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.6;
      }
    }
    
    .device-card {
      background: #0a0e27;
      padding: 15px;
      padding-top: 35px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      position: relative;
    }
    
    .hw-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.7em;
      font-weight: bold;
      text-transform: uppercase;
    }
      text-transform: uppercase;
    }
    
    .hw-badge.gpu {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }
    
    .hw-badge.mps {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
    }
    
    .hw-badge.cpu {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      color: white;
    }
    
    .device-card.active {
      border-left-color: #4ade80;
    }
    
    .device-card.overloaded {
      border-left-color: #ef4444;
      animation: pulse 2s infinite;
    }
    
    .device-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .device-url {
      font-family: monospace;
      font-size: 0.9em;
      color: #667eea;
    }
    
    .device-tps {
      font-size: 1.2em;
      font-weight: bold;
      color: #4ade80;
    }
    
    @keyframes tpsPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); color: #fbbf24; }
      100% { transform: scale(1); color: #4ade80; }
    }

    .device-queue {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 8px;
    }
    
    .queue-bar {
      flex: 1;
      height: 20px;
      background: #1a1f3a;
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }
    
    .queue-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #ef4444 100%);
      transition: width 0.3s ease;
    }
    
    .queue-label {
      font-size: 0.85em;
      color: #a0a0a0;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üéì LLM Training Game Benchmark</h1>
    <div class="status" id="status">Connecting to benchmark...</div>
    <div style="margin-top: 15px; font-size: 1.5em; font-weight: bold;">
      <span id="students-header-count" style="color: #4ade80;">0</span> / 
      <span id="students-header-total" style="color: #667eea;">0</span> 
      <span style="font-size: 0.8em; opacity: 0.8;">Students Connected</span>
    </div>
  </div>
  
  <div class="phase-indicator">
    <div class="phase pending" id="phase-0">
      <div>Phase 0</div>
      <div style="font-size: 0.8em; margin-top: 5px;">Teacher Connect</div>
    </div>
    <div class="phase pending" id="phase-1">
      <div>Phase 1</div>
      <div style="font-size: 0.8em; margin-top: 5px;">Student Connect</div>
    </div>
    <div class="phase pending" id="phase-2">
      <div>Phase 2</div>
      <div style="font-size: 0.8em; margin-top: 5px;">Game Start</div>
    </div>
    <div class="phase pending" id="phase-3">
      <div>Phase 3</div>
      <div style="font-size: 0.8em; margin-top: 5px;">Training</div>
    </div>
    <div class="phase pending" id="phase-4">
      <div>Phase 4</div>
      <div style="font-size: 0.8em; margin-top: 5px;">Query LLM</div>
    </div>
  </div>
  
  <div class="dashboard">
    <div class="card highlight">
      <h2>Connected Students</h2>
      <div class="metric" id="students-connected">0/0</div>
      <div class="sub-metric">Active connections</div>
    </div>
    
    <div class="card">
      <h2>Questions</h2>
      <div class="metric" id="questions-count">0</div>
      <div class="sub-metric">Submitted: <span id="questions-submitted">0</span> | Answered: <span id="questions-answered">0</span></div>
    </div>
    
    <div class="card">
      <h2>Challenges</h2>
      <div class="metric" id="challenges-count">0</div>
      <div class="sub-metric">
        Received: <span id="challenges-received">0</span> | 
        Passed: <span id="challenges-completed" style="color: #4ade80;">0</span> | 
        Failed: <span id="challenges-failed" style="color: #ef4444;">0</span>
      </div>
    </div>
    
    <div class="card">
      <h2>LLM Queries</h2>
      <div class="metric" id="llm-queries">0</div>
      <div class="sub-metric">Success: <span id="llm-success">0</span> | Learning: <span id="llm-learning">0</span></div>
    </div>
    
    <div class="card">
      <h2>Avg Response Time</h2>
      <div class="metric" id="avg-latency">0ms</div>
      <div class="sub-metric">Min: <span id="min-latency">0</span>ms | Max: <span id="max-latency">0</span>ms</div>
    </div>
    
    <div class="card">
      <h2>Throughput</h2>
      <div class="metric" id="throughput">0.0</div>
      <div class="sub-metric">Questions/sec</div>
    </div>
    
    <div class="card">
      <h2>Memory Usage</h2>
      <div class="metric" id="memory">0MB</div>
      <div class="sub-metric">Heap: <span id="heap-used">0</span>MB / <span id="heap-total">0</span>MB</div>
    </div>
    
    <div class="card">
      <h2>Errors</h2>
      <div class="metric" id="errors" style="color: #ef4444;">0</div>
      <div class="sub-metric">No errors detected</div>
    </div>
  </div>
  
  <div class="chart-container">
    <h2 style="margin-bottom: 15px;">Training Progress</h2>
    <div class="progress-bar">
      <div class="progress-fill" id="training-progress" style="width: 0%">0%</div>
    </div>
  </div>
  
  <div class="chart-container">
    <h2 style="margin-bottom: 15px;">Ollama Devices & Queues</h2>
    <div id="devices-container" style="display: grid; gap: 15px;">
      <div style="color: #a0a0a0; text-align: center;">Waiting for device information...</div>
    </div>
  </div>
  
  <div class="chart-container">
    <h2 style="margin-bottom: 15px;">Student Activity</h2>
    <div class="student-grid" id="student-grid">
      <!-- Students will be added here dynamically -->
    </div>
  </div>
  
  <div class="activity-log">
    <h2>Activity Log</h2>
    <div id="log-container">
      <div class="log-entry">
        <span>Waiting for benchmark to start...</span>
        <span class="time">--:--:--</span>
      </div>
    </div>
  </div>
  
  <script>
    const state = {
      students: new Map(),
      currentPhase: -1,
      startTime: null,
      stats: {
        studentsConnected: 0,
        totalStudents: 0,
        questionsSubmitted: 0,
        questionsAnswered: 0,
        challengesReceived: 0,
        challengesCompleted: 0,
        challengesFailed: 0,
        llmQueries: 0,
        llmSuccess: 0,
        llmLearning: 0,
        errors: 0,
        latencies: [],
        memory: { heapUsed: 0, heapTotal: 0, rss: 0 }
      }
    };
    
    function formatTime(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      return `${String(hours).padStart(2, '0')}:${String(minutes % 60).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
    }
    
    function updatePhase(phase) {
      if (phase > state.currentPhase) {
        // Mark previous phases as completed
        for (let i = 0; i <= state.currentPhase; i++) {
          const el = document.getElementById(`phase-${i}`);
          if (el) {
            el.classList.remove('active', 'pending');
            el.classList.add('completed');
          }
        }
        
        // Mark current phase as active
        const currentEl = document.getElementById(`phase-${phase}`);
        if (currentEl) {
          currentEl.classList.remove('pending', 'completed');
          currentEl.classList.add('active');
        }
        
        state.currentPhase = phase;
      }
    }
    
    function updateMetrics() {
      document.getElementById('students-connected').textContent = 
        `${state.stats.studentsConnected}/${state.stats.totalStudents}`;
      
      document.getElementById('questions-count').textContent = state.stats.questionsSubmitted;
      document.getElementById('questions-submitted').textContent = state.stats.questionsSubmitted;
      document.getElementById('questions-answered').textContent = state.stats.questionsAnswered;
      
      document.getElementById('challenges-count').textContent = state.stats.challengesReceived;
      document.getElementById('challenges-received').textContent = state.stats.challengesReceived;
      document.getElementById('challenges-completed').textContent = state.stats.challengesCompleted;
      document.getElementById('challenges-failed').textContent = state.stats.challengesFailed;
      
      document.getElementById('llm-queries').textContent = state.stats.llmQueries;
      document.getElementById('llm-success').textContent = state.stats.llmSuccess;
      document.getElementById('llm-learning').textContent = state.stats.llmLearning;
      
      if (state.stats.latencies.length > 0) {
        const avg = state.stats.latencies.reduce((a, b) => a + b, 0) / state.stats.latencies.length;
        const min = Math.min(...state.stats.latencies);
        const max = Math.max(...state.stats.latencies);
        
        document.getElementById('avg-latency').textContent = Math.round(avg) + 'ms';
        document.getElementById('min-latency').textContent = Math.round(min);
        document.getElementById('max-latency').textContent = Math.round(max);
      }
      
      if (state.startTime) {
        const elapsed = (Date.now() - state.startTime) / 1000;
        const throughput = state.stats.questionsSubmitted / elapsed;
        document.getElementById('throughput').textContent = throughput.toFixed(2);
      }
      
      const heapMB = (state.stats.memory.heapUsed / 1024 / 1024).toFixed(1);
      const heapTotalMB = (state.stats.memory.heapTotal / 1024 / 1024).toFixed(1);
      document.getElementById('memory').textContent = heapMB + 'MB';
      document.getElementById('heap-used').textContent = heapMB;
      document.getElementById('heap-total').textContent = heapTotalMB;
      
      document.getElementById('errors').textContent = state.stats.errors;
    }
    
    function addLogEntry(message, type = 'success') {
      const container = document.getElementById('log-container');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      
      const time = new Date().toLocaleTimeString();
      entry.innerHTML = `
        <span>${message}</span>
        <span class="time">${time}</span>
      `;
      
      container.insertBefore(entry, container.firstChild);
      
      // Keep only last 50 entries
      while (container.children.length > 50) {
        container.removeChild(container.lastChild);
      }
    }
    
    function updateStudentGrid() {
      const grid = document.getElementById('student-grid');
      if (!grid) {
        console.error('[VISUALIZER] Student grid element not found!');
        return;
      }
      
      console.log('[VISUALIZER] Updating student grid - Total students:', state.stats.totalStudents, 'Connected:', state.students.size);
      grid.innerHTML = '';
      
      for (let i = 1; i <= state.stats.totalStudents; i++) {
        const student = state.students.get(i) || { connected: false, mode: null };
        const card = document.createElement('div');
        card.className = 'student-card';
        
        if (student.connected) {
          card.classList.add('active');
          if (student.mode === 'asking') card.classList.add('asking');
          if (student.mode === 'answering') card.classList.add('answering');
        }
        
        card.textContent = `S${i}`;
        card.title = student.connected ? `Student ${i} - ${student.mode || 'idle'}` : `Student ${i} - disconnected`;
        grid.appendChild(card);
      }
      
      console.log('[VISUALIZER] Student grid updated with', grid.children.length, 'cards');
    }
    
    function updateDevices(data) {
      const container = document.getElementById('devices-container');
      
      if (!data.devices || data.devices.length === 0) {
        container.innerHTML = '<div style="color: #a0a0a0; text-align: center;">No devices detected</div>';
        return;
      }
      
      container.innerHTML = '';
      
      // Show local hardware info if available
      if (data.localHardware) {
        const hwInfo = document.createElement('div');
        hwInfo.style.cssText = 'font-size: 0.9em; color: #a0a0a0; margin-bottom: 15px; text-align: center;';
        hwInfo.innerHTML = `
          <span style="color: #667eea;">Local Hardware:</span> ${data.localHardware.cpu} (${data.localHardware.cores} cores)
          ${data.hasMetalAcceleration ? '<span style="color: #4ade80;"> ‚Ä¢ Metal/Neural Engine ‚úì</span>' : ''}
        `;
        container.appendChild(hwInfo);
      }
      
      data.devices.forEach(device => {
        const card = document.createElement('div');
        card.className = 'device-card';
        
        // Color code by queue size
        if (device.queueSize === 0 && device.busy === 0) {
          card.classList.add('active'); // Idle
        } else if (device.queueSize > 10) {
          card.classList.add('overloaded'); // Heavy load
        }
        
        // Use server-provided acceleration type
        const accel = device.acceleration || 'unknown';
        let hwType = 'cpu';
        let hwLabel = 'CPU';
        let hwEmoji = '‚ö™';
        
        switch (accel) {
          case 'metal':
            hwType = 'mps';
            hwLabel = 'Metal/MPS';
            hwEmoji = 'üçé';
            break;
          case 'cuda':
            hwType = 'gpu';
            hwLabel = 'CUDA GPU';
            hwEmoji = 'üü¢';
            break;
          case 'gpu':
            hwType = 'gpu';
            hwLabel = 'GPU';
            hwEmoji = 'üîµ';
            break;
          case 'offline':
            hwType = 'cpu';
            hwLabel = 'Offline';
            hwEmoji = '‚ö´';
            break;
          case 'cpu':
          default:
            hwType = 'cpu';
            hwLabel = 'CPU';
            hwEmoji = '‚ö™';
        }
        
        const maxCapacity = device.capacity || 1;
        const queuePercent = Math.min(100, (device.queueSize / maxCapacity) * 100);
        const onlineStatus = device.online === false ? 'üî¥ Offline' : 'üü¢ Online';
        const maxConcurrent = device.maxConcurrent || 1;
        
        card.innerHTML = `
          <div class="hw-badge ${hwType}">${hwEmoji} ${hwLabel}</div>
          <div class="device-header">
            <div class="device-url">${device.url}</div>
            <div class="device-tps" style="animation: ${device.tps > 0 ? 'tpsPulse 1s ease' : 'none'}">${device.tps.toFixed(1)} T/s</div>
          </div>
          <div style="font-size: 0.85em; color: #a0a0a0; margin-bottom: 5px;">
            Model: ${device.model}
          </div>
          <div style="font-size: 0.85em; color: #667eea; margin-bottom: 5px;">
            Processing: ${device.busy}/${maxConcurrent} | Max Queue: ${maxCapacity} | ${onlineStatus}
          </div>
          <div class="device-queue">
            <span class="queue-label">Queue:</span>
            <div class="queue-bar">
              <div class="queue-fill" style="width: ${queuePercent}%"></div>
            </div>
            <span class="queue-label">${device.queueSize}/${maxCapacity}</span>
          </div>
        `;
        
        container.appendChild(card);
      });
      
      // Add summary section with total capacity and strategy
      if (data.totalCapacity || data.strategy) {
        const summary = document.createElement('div');
        summary.style.cssText = 'font-size: 0.9em; color: #a0a0a0; margin-top: 15px; text-align: center; padding: 10px; background: #0a0e27; border-radius: 8px;';
        summary.innerHTML = `
          <span style="color: #667eea;">Strategy:</span> ${data.strategy || 'unknown'} | 
          <span style="color: #4ade80;">Total Max Queue:</span> ${data.totalCapacity || 0} requests
        `;
        container.appendChild(summary);
      }
    }
    
    // WebSocket connection to benchmark
    let ws;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    
    function connectWebSocket() {
      ws = new WebSocket('ws://localhost:3002');
      
      ws.onopen = () => {
        console.log('Connected to benchmark');
        document.getElementById('status').textContent = 'Connected - Monitoring benchmark...';
        reconnectAttempts = 0;
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        
        switch (data.type) {
          case 'init':
            state.stats.totalStudents = data.totalStudents;
            state.startTime = Date.now();
            console.log('[VISUALIZER] Initialized with', data.totalStudents, 'students');
            document.getElementById('students-header-total').textContent = data.totalStudents;
            
            // Apply current stats if provided (for late-connecting visualizer)
            if (data.currentStats) {
              state.stats.studentsConnected = data.currentStats.connectedStudents || 0;
              state.stats.questionsSubmitted = data.currentStats.questionsSubmitted || 0;
              state.stats.questionsAnswered = data.currentStats.answersReceived || 0;
              state.stats.challengesReceived = data.currentStats.challengesReceived || 0;
              state.stats.challengesCompleted = data.currentStats.challengesCompleted || 0;
              state.stats.challengesFailed = data.currentStats.challengesFailed || 0;
              state.stats.llmQueries = data.currentStats.llmQueriesSubmitted || 0;
              state.stats.llmSuccess = data.currentStats.llmRealResponses || 0;
              state.stats.llmLearning = data.currentStats.llmPlaceholderResponses || 0;
              state.stats.errors = data.currentStats.errors || 0;
              document.getElementById('students-header-count').textContent = state.stats.studentsConnected;
              console.log('[VISUALIZER] Restored stats - Connected:', state.stats.studentsConnected);
              
              // Pre-populate students map to prevent double-counting when student_connected messages arrive
              // We'll update them with actual info when the messages come through
              for (let i = 1; i <= state.stats.studentsConnected; i++) {
                state.students.set(i, { connected: true, mode: null });
              }
            }
            
            updateStudentGrid();
            updateMetrics();
            addLogEntry(`Benchmark initialized with ${data.totalStudents} students`, 'success');
            break;
            
          case 'phase':
            updatePhase(data.phase);
            addLogEntry(`Phase ${data.phase}: ${data.name}`, 'success');
            break;
            
          case 'student_connected':
            // Only increment if this is a new student (not already tracked)
            if (!state.students.has(data.id)) {
              state.stats.studentsConnected++;
            }
            state.students.set(data.id, { connected: true, mode: null });
            console.log('[VISUALIZER] Student connected:', data.id, '- Total:', state.stats.studentsConnected);
            document.getElementById('students-header-count').textContent = state.stats.studentsConnected;
            updateStudentGrid();
            updateMetrics();
            addLogEntry(`Student ${data.id} connected`, 'success');
            break;
            
          case 'question_submitted':
            state.stats.questionsSubmitted++;
            if (data.studentId) {
              const student = state.students.get(data.studentId);
              if (student) student.mode = 'asking';
            }
            updateStudentGrid();
            addLogEntry(`Question submitted by Student ${data.studentId}`, 'success');
            break;
            
          case 'answer_received':
            state.stats.questionsAnswered++;
            if (data.studentId) {
              const student = state.students.get(data.studentId);
              if (student) student.mode = 'answering';
            }
            updateStudentGrid();
            break;
            
          case 'challenge':
            state.stats.challengesReceived++;
            break;
            
          case 'challenge_completed':
            state.stats.challengesCompleted++;
            break;
            
          case 'challenge_failed':
            state.stats.challengesFailed++;
            addLogEntry(`‚ùå Student ${data.studentId} failed ${data.challengeType} - Training data corrupted!`, 'error');
            break;
            
          case 'llm_query':
            state.stats.llmQueries++;
            addLogEntry(`LLM query: "${data.question}"`, 'success');
            break;
            
          case 'llm_response':
            if (data.isPlaceholder) {
              state.stats.llmLearning++;
            } else {
              state.stats.llmSuccess++;
            }
            if (data.latency) {
              state.stats.latencies.push(data.latency);
            }
            addLogEntry(`LLM response (${data.latency}ms): ${data.isPlaceholder ? '‚ö†Ô∏è Still learning' : '‚úÖ Real answer'}`, data.isPlaceholder ? 'warning' : 'success');
            break;
            
          case 'memory':
            state.stats.memory = data.memory;
            break;
            
          case 'error':
            state.stats.errors++;
            addLogEntry(`Error: ${data.message}`, 'error');
            break;
            
          case 'progress':
            const progress = document.getElementById('training-progress');
            progress.style.width = data.percent + '%';
            progress.textContent = data.percent + '%';
            break;
            
          case 'devices':
            updateDevices(data);
            break;
        }
        
        updateMetrics();
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        document.getElementById('status').textContent = 'Connection error';
      };
      
      ws.onclose = () => {
        console.log('WebSocket closed');
        document.getElementById('status').textContent = 'Disconnected - Attempting to reconnect...';
        
        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          setTimeout(connectWebSocket, 2000);
        } else {
          document.getElementById('status').textContent = 'Connection failed - Please refresh';
        }
      };
    }
    
    // Try to connect
    connectWebSocket();
    
    // Update metrics every second
    setInterval(updateMetrics, 1000);
  </script>
</body>
</html>
